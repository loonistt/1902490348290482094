\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\thispagestyle{plain}

Актуальность темы: Поиск оптимального пути в лабиринте является классической задачей компьютерных наук, которая находит применение в робототехнике, компьютерных играх, системах навигации и анализе данных. Волновой алгоритм (алгоритм Ли) является одним из фундаментальных методов решения данной задачи, обеспечивающим нахождение кратчайшего пути на дискретной сетке \cite{lee1961}.

Цель работы: Разработать программное обеспечение для генерации лабиринтов, поиска в них оптимального пути с помощью волнового алгоритма и наглядной визуализации этого процесса.

Задачи исследования:
\begin{enumerate}[label=\arabic*., noitemsep,nolistsep]
    \item Изучить теоретические основы волнового алгоритма.
    \item Реализовать генератор лабиринтов на основе алгоритма DFS.
    \item Создать реализацию волнового алгоритма поиска пути.
    \item Разработать графический интерфейс для визуализации процесса.
    \item Протестировать работу программы на различных примерах.
\end{enumerate}

\newpage

\section{Теоретическая часть}
\thispagestyle{plain}

\subsection{Волновой алгоритм (алгоритм Ли)}
Волновой алгоритм (алгоритм Ли) — это алгоритм поиска кратчайшего пути на графе или сетке, основанный на принципе распространения волны от начальной точки до целевой \cite{lee1961,wikipedia2024}.

Основные принципы:
\begin{itemize}[noitemsep,nolistsep]
    \item Инициализация: Начальной точке присваивается значение 0;
    \item Распространение волны: Каждой новой достигнутой ячейке присваивается значение на 1 больше, чем у ячейки, из которой в неё пришли;
    \item Критерий остановки: Достижение конечной точки;
    \item Восстановление пути: Движение от конечной точки к начальной, выбирая на каждом шаге ячейку с меньшим значением.
\end{itemize}

\subsection{Генерация лабиринтов методом DFS}
Для генерации лабиринтов используется алгоритм поиска в глубину (DFS) с возвратом (backtracking). Этот метод гарантирует создание связного лабиринта без циклов, где существует единственный путь между любыми двумя точками \cite{knuth1997,koladaev2022}.

\newpage

\section{Практическая реализация}
\thispagestyle{plain}

\subsection{Архитектура программы}
Для реализации проекта был выбран язык программирования Python, что обусловлено его простотой, читаемостью и наличием мощных библиотек для научных вычислений и визуализации \cite{python2024}. Разработка велась в среде PyCharm с использованием библиотеки Pygame для графического интерфейса \cite{pygame2024}.

Пример кода инициализации PyGame:
\begin{lstlisting}
import pygame
import sys
import random

# Инициализация
pygame.init()
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
clock = pygame.time.Clock()

# Цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BLUE = (0, 120, 255)
GREEN = (52, 199, 89)
RED = (255, 59, 48)
GRAY = (200, 200, 200)
YELLOW = (255, 200, 0)
PURPLE = (175, 82, 222) # Цвет для выбора
\end{lstlisting}

\subsection{Класс Maze: генерация лабиринтов}
Класс Maze отвечает за создание и представление лабиринта \cite{isadha2024}.

Метод \texttt{generate()} — алгоритм генерации лабиринта:
\begin{lstlisting}
class Maze:
    def __init__(self, width=21, height=15):
        self.width = width
        self.height = height
        self.start = (1, 1)
        self.end = (width - 2, height - 2)
        self.grid = self.generate()

    def generate(self):
        grid = [[1] * self.width for _ in range(self.height)]
        stack = [(1, 1)]
        grid[1][1] = 0
        
        while stack:
            x, y = stack[-1]
            neighbors = []
            
            for dx, dy in [(0, 2), (2, 0), (0, -2), (-2, 0)]:
                nx, ny = x + dx, y + dy
                if 0 < nx < self.width - 1 and 0 < ny < self.height - 1 and grid[ny][nx] == 1:
                    neighbors.append((dx, dy))
            
            if neighbors:
                dx, dy = random.choice(neighbors)
                nx, ny = x + dx, y + dy
                grid[y + dy // 2][x + dx // 2] = 0
                grid[ny][nx] = 0
                stack.append((nx, ny))
            else:
                stack.pop()
        
        grid[1][1] = 2
        grid[self.height - 2][self.width - 2] = 3
        return grid
\end{lstlisting}

\subsection{Класс WaveSolver: реализация волнового алгоритма}
Класс WaveSolver реализует волновой алгоритм поиска пути \cite{novikov2009,skorubsky2023}.

\begin{lstlisting}
class WaveSolver:
    def __init__(self, maze):
        self.maze = maze
        self.path = []
        self.dist = [[-1] * maze.width for _ in range(maze.height)]
        self.found = False

    def solve(self):
        sx, sy = self.maze.start
        ex, ey = self.maze.end
        self.dist[sy][sx] = 0
        queue = [(sx, sy)]
        
        while queue:
            x, y = queue.pop(0)
            
            if (x, y) == (ex, ey):
                self.found = True
                self.reconstruct_path()
                return True
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if (0 <= nx < self.maze.width and 0 <= ny < self.maze.height and
                    self.maze.grid[ny][nx] != 1 and self.dist[ny][nx] == -1):
                    self.dist[ny][nx] = self.dist[y][x] + 1
                    queue.append((nx, ny))
        
        return False
\end{lstlisting}

\subsection{Класс App: интерфейс и визуализация}
Класс App является основным управляющим классом программы, отвечающим за графический интерфейс, обработку событий и визуализацию \cite{trofimov2023}.

\subsection{Результаты и тестирование}
Разработанная программа предоставляет следующий функционал:
\begin{itemize}[noitemsep,nolistsep]
    \item Генерация случайных лабиринтов;
    \item Реализация волнового алгоритма поиска пути;
    \item Нахождение кратчайшего пути;
    \item Визуализация процесса поиска пути.
\end{itemize}

\textbf{Пример работы программы:}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/2025-12-24_17-53-48.png}
    \caption{Пример работы программы: волновой алгоритм поиска пути в лабиринте}
    \label{fig:wave_example}
\end{figure}

На рисунке \ref{fig:wave_example} представлен пример работы программы. Зелёным кружком обозначена начальная точка, красным — конечная. Синим цветом показано распространение волны алгоритма, жёлтым — найденный кратчайший путь. Серая область представляет собой стены лабиринта.

Программа была протестирована на лабиринтах различных размеров и конфигураций. Во всех случаях волновой алгоритм корректно находил кратчайший путь при его наличии \cite{gorbatov2010}. В случае отсутствия пути между точками программа корректно сообщала о невозможности построения маршрута.

\newpage

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

В ходе выполнения курсовой работы были успешно решены все поставленные задачи:
\begin{enumerate}[label=\arabic*., noitemsep,nolistsep]
    \item Изучены теоретические основы волнового алгоритма;
    \item Разработан генератор лабиринтов на основе DFS;
    \item Реализован волновой алгоритм поиска пути;
    \item Создан графический интерфейс с визуализацией;
    \item Проведено тестирование и анализ результатов.
\end{enumerate}

Разработанная программа может использоваться как образовательное пособие для изучения алгоритмов, демонстрационный инструмент для лекций и семинаров, а также основа для более сложных систем навигации \cite{koladaev2022,trofimov2023}.